\input{macros}

%#############################################################################################################%
%#############################################################################################################%
%#############################################################################################################%

\title{Distributing the Heat Equation}
\author{Tom Cornebize \and Yassine Hamoudi}
\date{Sunday, December 7th 2014}

\begin{document}

\maketitle

%#############################################################################################################%
%#############################################################################################################%
%#############################################################################################################%

\section{Cellular automata}

\begin{question}

\begin{lemma}
  \label{nextStep}
  $N^2$ applications of function $\delta$ are necessary to compute $X^t$ from $X^{t-1}$.
\end{lemma}

\begin{proof}
 Each cell $X^{t}_{i,j}$ needs one application of $\delta$ to be computed from $X^{t-1}_{i,j}$. There are $N^2$ cells, so $N^2$ applications of $\delta$ are needed.
\end{proof}

\begin{prop}
  $tN^2$ applications of function $\delta$ are necessary to compute $X^t$ on \textlbrackdbl $0,N-1$ \textrbrackdbl$^2$.
\end{prop}

\begin{proof}
 $X^t$ is obtained after $t$ applications of $\ddelta$ on $X^0$. Each application needs $N^2$ calls to $\delta$ according to lemma \ref{nextStep}. The whole computation needs $tN^2$ applications of $\delta$.
\end{proof}

\end{question}

%#############################################################################################################%

\begin{question}

Let $p^2$ be the number of processors.

For the sake of simplicity, we will suppose that $p$ divides $N$. Take $n = \frac{N}{p}$.

We divide the grid into square zones of size $n$. Each of this zones is given to one processor, which stores the data in its own memory and performs the computation of $\delta$ for all its cells. See figure \ref{q2:draw} for an example.

At each step of computation, each processor updates its sub-matrix cells using a temporary sub-matrix that replaces the old one once the computation step is finished. Indeed,  if we update the cells ``in place'', we overwrite values that are still necessary to compute other cells.

The computation of $\delta$ for the cells at the edges of the zones requires communication to retrieve the current states of their neighbours in other zones.

\begin{figure}
\caption{Graphical representation of the topology for $N=6$ and $p^2=9$.}
\label{q2:draw}
\begin{center}
\begin{tikzpicture}
    \tikzstyle{case}=[draw, minimum height=1cm, minimum width=1cm, thick, fill=white, anchor=south west];
    \tikzstyle{redcase}=[draw, minimum height=2.4cm, minimum width=2.4cm, thick, fill=none, draw=red, anchor=south west];

    \foreach \x in {0,...,5} {
        \foreach \y in {0,...,5} {
            \node[case] at (1.2*\y,1.2*\x) {};
        }
    }
    \foreach \x in {0,...,2} {
        \foreach \y in {0,...,2} {
            \node[redcase] at (2.4*\y-0.1,2.4*\x-0.1) {};
        }
    }
\end{tikzpicture}
\end{center}
\end{figure}


\end{question}

%#############################################################################################################%

\begin{question}
 
 ~\\
\begin{algorithm}[H]
\SetKwFunction{myrow}{My\_Proc\_Row}
\SetKwFunction{mycol}{My\_Proc\_Col}
\DontPrintSemicolon
\LinesNotNumbered
var A: array[0..n-1,0..n-1] of real\;
var NEXT: array[0..n+1,0..n+1] of real\;
%var bufferLeft, bufferRight, bufferTop, bufferBottom: array[0..n-1] of real\;
%var bufferLeftCorner, bufferRightCorner, bufferTopCorner, bufferBottomCorner: real numbers\;
$myrow \leftarrow \myrow{}$;
$mycol \leftarrow \mycol{}$;


\iffalse
\BlankLine
$voisinsAjoutes \longleftarrow []$\;
\For{$n \in noeudsContractes$}{
	\visibilite{n}$=1$ \tcp*{chaque noeud contracté est rendu invisible.}
	\For{$m$ : noeud voisin de $n$}{
		\If{$m$ n'est pas un voisin de $contracteur$}{
		\ajouterVoisin{contracteur,m}  \tcp*{$contracteur$ et $m$ deviennent voisins}
		\add{voisinsAjoutes, m} \tcp*{on ajoute $m$ à $voisinsAjoutes$}
		}
	}
}
\push{\stack{G}, \Fleur{contrac,noeudsContractes,voisinsAjoutes}} \tcp*{on ajoute la fleur en haut de pile}
\Return{$G$};
\fi
\caption{Stencil algorithm on a toric 2D grid\label{algoq3}}
\end{algorithm}
~\\
 
% faire les échanges modulo n (permet de traiter les bords)
 
\end{question}

%#############################################################################################################%

\section{Average automata}

\begin{question}
 
 See the implementation in \texttt{average.c}.
 
\end{question} 
 
%#############################################################################################################%

\begin{question}
 
\begin{prop}
 In the case of a \textit{p-average automaton}, $\ddelta$ is linear.
\end{prop}

\begin{proof}
 Let $\ddelta$ be the global transformation function of a \textit{p-average automaton}. To prove that $\ddelta$ is linear, it suffices to prove that the local transformation function $\delta$ is linear:
 
 \[ \delta \left( \begin{array}{ | c | c | c |} \hline
  a & b & c \\ \hline
  d & e & f \\ \hline
  g & h & i \\ \hline
 \end{array} \right) = (1-p) \cdot e+p \cdot \frac{b+d+f+h}{4}\]
 
 Let consider a real $k \in \RR$, two local configurations $\begin{array}{ | c | c | c |} \hline
  a & b & c \\ \hline
  d & e & f \\ \hline
  g & h & i \\ \hline
 \end{array}$ and $\begin{array}{ | c | c | c |} \hline
  a' & b' & c' \\ \hline
  d' & e' & f' \\ \hline
  g' & h' & i' \\ \hline
 \end{array}$. We have:
 
 \[\begin{split}
 \delta \left( k \cdot \begin{array}{ | c | c | c |} \hline
  a & b & c \\ \hline
  d & e & f \\ \hline
  g & h & i \\ \hline
 \end{array} + \begin{array}{ | c | c | c |} \hline
  a' & b' & c' \\ \hline
  d' & e' & f' \\ \hline
  g' & h' & i' \\ \hline
 \end{array} \right) & = (1-p) \cdot (k \cdot e+e') + p \cdot \frac{(k \cdot b+b')+(k \cdot d+d')+(k \cdot f+f')+(k \cdot h+h')}{4}  \\
		     & = k \cdot \left( (1-p) \cdot e+p \cdot \frac{b+d+f+h}{4} \right) + (1-p) \cdot e'+p \cdot \frac{b'+d'+f'+h'}{4} \\
		     & = k \cdot \delta \left( \begin{array}{ | c | c | c |} \hline
  a & b & c \\ \hline
  d & e & f \\ \hline
  g & h & i \\ \hline
 \end{array} \right) + \delta \left( \begin{array}{ | c | c | c |} \hline
  a' & b' & c' \\ \hline
  d' & e' & f' \\ \hline
  g' & h' & i' \\ \hline
 \end{array} \right)      
 \end{split}\]
 
Thus $\delta$ is linear, and $\ddelta$ too.
\end{proof}

Let's consider a configuration $X$. For $0 \leq i,j \leq N-1$ we define the matrix $E^{i,j}$ such that $E^{i,j}_{i,j} = 1$ and $E^{i,j}_{k,l} = 0$ otherwise. We obtain : $X = \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} X_{i,j} \cdot E^{i,j}$

Since $\ddelta$ is linear, for all t : 
\[ \ddeltat (X) = \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} X_{i,j} \cdot \ddeltat (E^{i,j})\]
 
Moreover : 
\begin{equation}
 \label{expanddelta}
 \begin{split}
    \ddeltatt (X) & = \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} X_{i,j} \cdot \ddeltatt (E^{i,j}) \\
		  & = \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} X_{i,j} \cdot \ddeltat(\ddeltat (E^{i,j})) \\
		  & = \sum_{i=0}^{N-1} \sum_{j=0}^{N-1} X_{i,j} \sum_{k=0}^{N-1} \sum_{l=0}^{N-1} \ddeltat (E^{i,j})_{k,l} \cdot \ddeltat (E^{i,j})
 \end{split}
\end{equation}
 
\begin{prop}
 Equation \ref{expanddelta} enables us to compute $\ddeltat(X)$ in time $O(log t)$.
\end{prop}

\begin{proof}
 First of all, if $\ddeltat (E^{0,0})$ is already computed, we directly obtained by translation $\ddeltat (E^{i,j})$, for all $i,j$.
 
 Let $T(t)$ the time needed to compute $\ddeltat(X)$. According to equation \ref{expanddelta} and previous remark, we have:
 \[\begin{split}
    T(2t) & = T(t) + O(1) \\
	  & = O(\log t)
   \end{split}
\]
 
 Thus, using the algorithm described by equation \ref{expanddelta}, we can compute $\ddeltat(X)$ in time $O(\log t)$. 
\end{proof}

\begin{prop}
 The time complexity $T'(t,N)$ in terms of both $t$ and $N$is $T'(t,N) = ...$.
\end{prop}

\begin{proof}
 
\end{proof}


\end{question}

%#############################################################################################################%

\section{Thermal reservoirs}

\begin{question}
 
 \begin{ex}
  
 \end{ex}

\end{question}


%#############################################################################################################%

\begin{question}

 \begin{prop}
    For a \textit{p-average automaton} with constants, $\ddelta$ can be non-linear.
 \end{prop}

 \begin{proof}
   Let's consider the following local configuration:
   \[\begin{array}{ | c | c | c |} \hline
    0 & 0 & 0 \\ \hline
    0 & 1 & 0 \\ \hline
    0 & 0 & 0 \\ \hline
  \end{array}\]
  
  We assume that 1 is a constant, but 0 not. We take $p=0.5$.
  
  We have:
 \[\begin{split}
 \delta \left(\begin{array}{ | c | c | c |} \hline
  0 & 0 & 0 \\ \hline
  0 & 1 & 0 \\ \hline
  0 & 0 & 0 \\ \hline
 \end{array} + \begin{array}{ | c | c | c |} \hline
  0 & 0 & 0 \\ \hline
  0 & 1 & 0 \\ \hline
  0 & 0 & 0 \\ \hline
 \end{array} \right) & = \delta \left(\begin{array}{ | c | c | c |} \hline
  0 & 0 & 0 \\ \hline
  0 & 2 & 0 \\ \hline
  0 & 0 & 0 \\ \hline
 \end{array} \right) \\
		     & = 0.5 \cdot 2 = 1    
 \end{split}\]  
  
  However:
 \[\begin{split}
 \delta \left(\begin{array}{ | c | c | c |} \hline
  0 & 0 & 0 \\ \hline
  0 & 1 & 0 \\ \hline
  0 & 0 & 0 \\ \hline
 \end{array}\right) + \delta \left(\begin{array}{ | c | c | c |} \hline
  0 & 0 & 0 \\ \hline
  0 & 1 & 0 \\ \hline
  0 & 0 & 0 \\ \hline
 \end{array} \right) & = 1 + 1 = 2
 \end{split}\]  
  
 $\delta$ is not linear, and so $\ddelta$ too. This result proves that $\ddelta$ can be non-linear for a \textit{p-average automaton} with constants.
 \end{proof}

\end{question}

 
%#############################################################################################################%
%#############################################################################################################%
%#############################################################################################################%

\end{document}
