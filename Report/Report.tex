\input{macros}

%#############################################################################################################%
%#############################################################################################################%
%#############################################################################################################%

\title{Distributing the Heat Equation}
\author{Tom Cornebize \and Yassine Hamoudi}
\date{Sunday, December 7th 2014}

\begin{document}

\maketitle

%#############################################################################################################%
%#############################################################################################################%
%#############################################################################################################%

\section{Cellular automata}

\begin{question}

\begin{lemma}
  \label{nextStep}
  $N^2$ applications of function $\delta$ are necessary to compute $X^t$ from $X^{t-1}$.
\end{lemma}

\begin{proof}
 Each cell $X^{t}_{i,j}$ needs one application of $\delta$ to be computed from $X^{t-1}_{i,j}$. There are $N^2$ cells, so $N^2$ applications of $\delta$ are needed.
\end{proof}

\begin{prop}
  $tN^2$ applications of function $\delta$ are necessary to compute $X^t$ on \textlbrackdbl $0,N-1$ \textrbrackdbl$^2$.
\end{prop}

\begin{proof}
 $X^t$ is obtained after $t$ applications of $\ddelta$ on $X^0$. Each application needs $N^2$ calls to $\delta$ according to lemma \ref{nextStep}. The whole computation needs $tN^2$ applications of $\delta$.
\end{proof}

\end{question}

%#############################################################################################################%

\begin{question}

Let $p^2$ be the number of processors.

For the sake of simplicity, we will suppose that $p$ divides $N$. Take $n = \frac{N}{p}$.

We divide the grid into square zones of size $n$. Each of this zones is given to one processor, which stores the data in its own memory and performs the computation of $\delta$ for all its cells. See figure \ref{q2:draw} for an example.

At each step of computation, each processor updates its sub-matrix cells using a temporary sub-matrix that replaces the old one once the computation step is finished. Indeed,  if we update the cells ``in place'', we overwrite values that are still necessary to compute other cells.

The computation of $\delta$ for the cells at the edges of the zones requires communication to retrieve the current states of their neighbours in other zones.

\begin{figure}
\caption{Graphical representation of the topology for $N=6$ and $p^2=9$.}
\label{q2:draw}
\begin{center}
\begin{tikzpicture}
    \tikzstyle{case}=[draw, minimum height=1cm, minimum width=1cm, thick, fill=white, anchor=south west];
    \tikzstyle{redcase}=[draw, minimum height=2.4cm, minimum width=2.4cm, thick, fill=none, draw=red, anchor=south west];

    \foreach \x in {0,...,5} {
        \foreach \y in {0,...,5} {
            \node[case] at (1.2*\y,1.2*\x) {};
        }
    }
    \foreach \x in {0,...,2} {
        \foreach \y in {0,...,2} {
            \node[redcase] at (2.4*\y-0.1,2.4*\x-0.1) {};
        }
    }
\end{tikzpicture}
\end{center}
\end{figure}


\end{question}

%#############################################################################################################%

\begin{question}
 
 ~\\
\begin{algorithm}[H]
\SetKwFunction{myrow}{My\_Proc\_Row}
\SetKwFunction{mycol}{My\_Proc\_Col}
\DontPrintSemicolon
\LinesNotNumbered
var A: array[0..n-1,0..n-1] of real\;
var NEXT: array[0..n+1,0..n+1] of real\;
%var bufferLeft, bufferRight, bufferTop, bufferBottom: array[0..n-1] of real\;
%var bufferLeftCorner, bufferRightCorner, bufferTopCorner, bufferBottomCorner: real numbers\;
$myrow \leftarrow \myrow{}$;
$mycol \leftarrow \mycol{}$;


\iffalse
\BlankLine
$voisinsAjoutes \longleftarrow []$\;
\For{$n \in noeudsContractes$}{
	\visibilite{n}$=1$ \tcp*{chaque noeud contracté est rendu invisible.}
	\For{$m$ : noeud voisin de $n$}{
		\If{$m$ n'est pas un voisin de $contracteur$}{
		\ajouterVoisin{contracteur,m}  \tcp*{$contracteur$ et $m$ deviennent voisins}
		\add{voisinsAjoutes, m} \tcp*{on ajoute $m$ à $voisinsAjoutes$}
		}
	}
}
\push{\stack{G}, \Fleur{contrac,noeudsContractes,voisinsAjoutes}} \tcp*{on ajoute la fleur en haut de pile}
\Return{$G$};
\fi
\caption{Stencil algorithm on a toric 2D grid\label{algoq3}}
\end{algorithm}
~\\
 
% faire les échanges modulo n (permet de traiter les bords)
 
\end{question}

%#############################################################################################################%

\section{Average automata}

\begin{question}
 
 See the implementation in \texttt{average.c}.
 
\end{question} 
 
%#############################################################################################################%

\begin{question}
 
\begin{prop}
 In the case of a \textit{p-average automaton}, $\ddelta$ is linear.
\end{prop}

\begin{proof}
 Let $\ddelta$ be the global transformation function of a \textit{p-average automaton}. To prove that $\ddelta$ is linear, it suffices to prove that the local transformation function $\delta$ is linear:
 
 \[ \delta \left( \begin{array}{ | c | c | c |} \hline
  a & b & c \\ \hline
  d & e & f \\ \hline
  g & h & i \\ \hline
 \end{array} \right) = (1-p) \cdot e+p \cdot \frac{b+d+f+h}{4}\]
 
 Let consider a real $k \in \RR$, two local configurations $\begin{array}{ | c | c | c |} \hline
  a & b & c \\ \hline
  d & e & f \\ \hline
  g & h & i \\ \hline
 \end{array}$ and $\begin{array}{ | c | c | c |} \hline
  a' & b' & c' \\ \hline
  d' & e' & f' \\ \hline
  g' & h' & i' \\ \hline
 \end{array}$. We have:
 
 \[\begin{split}
 \delta \left( k \cdot \begin{array}{ | c | c | c |} \hline
  a & b & c \\ \hline
  d & e & f \\ \hline
  g & h & i \\ \hline
 \end{array} + \begin{array}{ | c | c | c |} \hline
  a' & b' & c' \\ \hline
  d' & e' & f' \\ \hline
  g' & h' & i' \\ \hline
 \end{array} \right) & = (1-p) \cdot (k \cdot e+e') + p \cdot \frac{(k \cdot b+b')+(k \cdot d+d')+(k \cdot f+f')+(k \cdot h+h')}{4}  \\
		     & = k \cdot \left( (1-p) \cdot e+p \cdot \frac{b+d+f+h}{4} \right) + (1-p) \cdot e'+p \cdot \frac{b'+d'+f'+h'}{4} \\
		     & = k \cdot \delta \left( \begin{array}{ | c | c | c |} \hline
  a & b & c \\ \hline
  d & e & f \\ \hline
  g & h & i \\ \hline
 \end{array} \right) + \delta \left( \begin{array}{ | c | c | c |} \hline
  a' & b' & c' \\ \hline
  d' & e' & f' \\ \hline
  g' & h' & i' \\ \hline
 \end{array} \right)      
 \end{split}\]
 
Thus $\delta$ is linear, and $\ddelta$ too.
\end{proof}

We denote $\delta^t$ the $t-th$ iterated function of $\delta$.

Since $\delta$ is linear we obtain:

 \[\begin{split}
  \delta^t \left(\begin{array}{ | c | c | c |} \hline
    a & b & c \\ \hline
    d & e & f \\ \hline
    g & h & i \\ \hline
  \end{array} \right) & = (1-p)^t \cdot e + \left(\frac{p}{4}\right)^t \cdot \left(\delta^t(b) + \delta^t(d) + \delta^t(f) + \delta^t(h)\right)
 \end{split}\]
 
\end{question}

%#############################################################################################################%

\begin{question}

 \begin{prop}
    For a \textit{p-average automaton} with constants, $\ddelta$ can be non-linear.
 \end{prop}

 \begin{proof}
   Let consider the following local configuration:
   \[\begin{array}{ | c | c | c |} \hline
    0 & 0 & 0 \\ \hline
    0 & 1 & 0 \\ \hline
    0 & 0 & 0 \\ \hline
  \end{array}\]
  
  We assume that 1 is a constant, but 0 not. We take $p=1$.
  
  We have:
 \[\begin{split}
 \delta \left(\begin{array}{ | c | c | c |} \hline
  0 & 0 & 0 \\ \hline
  0 & 1 & 0 \\ \hline
  0 & 0 & 0 \\ \hline
 \end{array} + \begin{array}{ | c | c | c |} \hline
  0 & 0 & 0 \\ \hline
  0 & 1 & 0 \\ \hline
  0 & 0 & 0 \\ \hline
 \end{array} \right) & = \begin{array}{ | c | c | c |} \hline
  0 & 0 & 0 \\ \hline
  0 & 2 & 0 \\ \hline
  0 & 0 & 0 \\ \hline
 \end{array} \\
		     & = 0    
 \end{split}\]  
  
  However:
 \[\begin{split}
 \delta \left(\begin{array}{ | c | c | c |} \hline
  0 & 0 & 0 \\ \hline
  0 & 1 & 0 \\ \hline
  0 & 0 & 0 \\ \hline
 \end{array}\right) + \delta \left(\begin{array}{ | c | c | c |} \hline
  0 & 0 & 0 \\ \hline
  0 & 1 & 0 \\ \hline
  0 & 0 & 0 \\ \hline
 \end{array} \right) & = 1 + 1 = 2
 \end{split}\]  
  
 This counter-example proves that $\delta$ is not linear, and so $\ddelta$ too. 
 \end{proof}

\end{question}

 
%#############################################################################################################%
%#############################################################################################################%
%#############################################################################################################%

\end{document}
